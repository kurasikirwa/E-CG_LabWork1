# Лабораторная работа №1  

Здесь представлены описания функций библиотеки **GL** задействованной в лабораторной работе №1
1.  **glut функции**  
    * [glutInit](#glutinit)
    * [glutInitDisplayMode](#glutinitdisplaymode)
    * [glutInitWindowPosition, glutInitWindowSize](#glutinitwindowposition-glutinitwindowsize)
    * [glutCreateWindow](#glutcreatewindow)
    * [glutDisplayFunc](#glutdisplayfunc)








# glutInit
**`glutInit`** инициализирует библиотеку **GLUT** и согласует сеанс с оконной системой.

## С спецификация
```c
void glutInit(int *argcp, char **argv);
```

## Параметры
### *argcp*
>Указатель на немодифицированную переменную *argc* программы из **main**. По возвращении значение, на которое указывает *argcp*, будет обновлено, отому что **`glutInit`** извлекает все параметры командной строки, предназначенные для библиотеки **GLUT**.
### *argv*
>Немодифицированная переменная *argv* программы из файла main.	Как и в случае с *argcp*, данные для argv будут обновляться, потому что **`glutInit`** извлекает любые параметры командной строки, понятные библиотеке **GLUT**.  

## Описание
**`glutInit`** инициализирует библиотеку **GLUT** и согласует сеанс с оконной системой. Во время этого процесса **`glutInit`** может вызвать завершение программы **GLUT** с сообщением об ошибке для пользователя, если **GLUT** не может быть правильно инициализирован. Примеры этой ситуации включают сбой подключения к оконной системе, отсутствие поддержки оконной системой OpenGL и недопустимые параметры командной строки.  

**`glutInit`** также обрабатывает параметры командной строки, но анализ конкретных параметров зависит от оконной системы.

[Источник](https://www.opengl.org/resources/libraries/glut/spec3/node10.html)
***

# glutInitDisplayMode
**`glutInitDisplayMode`** устанавливает начальный режим отображения.  

## C Спецификация
```c
void glutInitDisplayMode(unsigned int mode);
```

## Параметры
### *mode*
>Режим отображения, который может быть представлен одной из следующих констант или комбинацией этих констант с помощью побитового ИЛИ.

|Константа	      |Значение|
|-----------------|--------|
|GLUT_RGB	        |Для отображения графической информации используются 3 компоненты цвета RGB.|
|GLUT_RGBA	      |То же что и RGB, но используется также 4 компонента ALPHA (прозрачность).|
|GLUT_INDEX	      |Цвет задается не с помощью RGB компонентов, а с помощью палитры. Используется для старых дисплеев, где количество цветов например 256. |
|GLUT_SINGLE	    |Вывод в окно осуществляется с использованием 1 буфера. Обычно используется для статического вывода информации.|
|GLUT_DOUBLE	    |Вывод в окно осуществляется с использованием 2 буферов. Применяется для анимации, чтобы исключить эффект мерцания.|
|GLUT_ACCUM	      |Использовать также буфер накопления (Accumulation Buffer). Этот буфер применяется для создания специальных эффектов, например отражения и тени.|
|GLUT_ALPHA	      |Использовать буфер ALPHA. Этот буфер, как уже говорилось используется для задания 4-го компонента цвета - ALPHA. Обычно применяется для таких эффектов как прозрачность объектов и антиалиасинг.|
|GLUT_DEPTH	      |Создать буфер глубины. Этот буфер используется для отсечения невидимых линий в 3D пространстве при выводе на плоский экран монитора.|
|GLUT_STENCIL	    |Буфер трафарета используется для таких эффектов как вырезание части фигуры, делая этот кусок прозрачным. Например, наложив прямоугольный трафарет на стену дома, вы получите окно, через которое можно увидеть что находится внутри дома.|
|GLUT_MULTISAMPLE | Битовая маска для выбора окна с поддержкой мультисэмплинга. Если мультисэмплинг недоступен, автоматически будет выбрано окно без мультисэмплинга. Примечание: как клиентская, так и серверная реализации OpenGL должны поддерживать расширение *GLX_SAMPLE_SGIS* , чтобы мультисэмплинг был доступен.|
|GLUT_STEREO	    |Этот флаг используется для создания стереоизображений. Используется редко, так как для просмотра такого изображения нужна специальная аппаратура.|
|GLUT_LUMINANCE   | Битовая маска для выбора окна с цветовой моделью "яркости". Эта модель обеспечивает функциональность цветовой модели OpenGL RGBA, но зеленый и синий компоненты не сохраняются в буфере кадров. Вместо этого красный компонент каждого пикселя преобразуется в индекс между нулем и glutGet(GLUT_WINDOW_COLORMAP_SIZE)-1 и просматривается в цветовой карте для каждого окна, чтобы определить цвет пикселей в окне. Начальная цветовая карта окон GLUT_LUMINANCE инициализируется как линейная шкала серого, но может быть изменена с помощью процедур цветовой карты **GLUT**.|

### Описание
Начальный режим отображения используется при создании окон верхнего	уровня, дочерних окон и наложений для определения режима отображения OpenGL для создаваемого окна или наложения.  

[Источник](https://www.opengl.org/resources/libraries/glut/spec3/node12.html)
***

# glutInitWindowPosition, glutInitWindowSize
**`glutInitWindowPosition`**, **`glutInitWindowSize`** устанавливаюет начальное положение и размер окна соответственно.

## С спецификация
```c
void glutInitWindowSize(int width, int height);
void glutInitWindowPosition(int x, int y);
```

## Параметры
### *width*
>Ширина в пикселях.
### *height*
>Высота в пикселях.
### *x*
>Расположение окна в X пикселе.
### *y*
>Расположение окна в Y пикселе.

## Описание
Окна, созданные с помощью **[glutCreateWindow](#glutcreatewindow)** , будут запрошены для создания с текущими начальными положением и размером окна.  

Начальное значение состояния **GLUT** начальной позиции окна равно -1 и -1. Если компонент X или Y для начального положения окна отрицателен, фактическое положение окна определяется оконной системой. Начальное значение состояния **GLUT** начального размера окна равно 300 на 300. Компоненты начального размера окна должны быть больше нуля.  

Назначение начальных значений положения и размера окна состоит в том, чтобы предоставить оконной системе предложение относительно начального размера и положения окна. Оконная система не обязана использовать эту информацию. Следовательно, программы **GLUT** не должны предполагать, что окно было создано с указанным размером или положением. Программа **GLUT** должна использовать обратный вызов изменения формы окна, чтобы определить истинный размер окна.  

[Источник](https://www.opengl.org/resources/libraries/glut/spec3/node11.html)
***

# glutCreateWindow
**`glutCreateWindow`** создает окно верхнего уровня.

## С спецификация
```c
int glutCreateWindow(char *name);
```

## Параметры
### *name*
>Строка символов ASCII для использования в качестве имени окна.
>
## Описание
**`glutCreateWindow`** создает окно верхнего уровня. Имя будет предоставлено оконной системе как имя окна. Цель состоит в том, чтобы оконная система пометила окно именем.  

Неявно, текущее окно устанавливается на вновь созданное окно.  

Каждое созданное окно имеет уникальный связанный с ним контекст OpenGL. Изменения состояния связанного с окном контекста OpenGL можно выполнить сразу после создания окна.  

Состояние отображения окна изначально предназначено для отображения окна. Но на состояние отображения окна фактически не действуют до тех пор, пока не будет введен **[glutMainLoop](#glutmainloop)** . Это означает, что до тех пор, пока не будет вызван **[glutMainLoop](#glutmainloop)** , рендеринг в созданное окно неэффективен, поскольку окно еще не может быть отображено.  

Возвращаемое значение представляет собой уникальный небольшой целочисленный идентификатор окна. Диапазон выделенных идентификаторов начинается с единицы. Этот идентификатор окна можно использовать при вызове **glutSetWindow** .

[Источник](https://www.opengl.org/resources/libraries/glut/spec3/node16.html)
***

# glutDisplayFunc
**`glutDisplayFunc`** устанавливает обратный вызов дисплея для текущего окна.

## С спецификация
```c
void glutDisplayFunc(void (*func)(void));
```
## Параметры
### *func*
>Новая функция обратного вызова дисплея.

## Описание
**`glutDisplayFunc`** устанавливает обратный вызов дисплея для текущего окна . Когда **GLUT** определяет, что необходимо повторно отобразить нормальную плоскость окна, вызывается обратный вызов display для окна. Перед обратным вызовом текущее окно устанавливается в окно, которое необходимо повторно отобразить, и (если обратный вызов отображения наложения не зарегистрирован) используемый слой устанавливается в нормальную плоскость. Обратный вызов дисплея вызывается без параметров. Вся нормальная область плоскости должна быть повторно отображена в ответ на обратный вызов (включая вспомогательные буферы, если ваша программа зависит от их состояния).  

**GLUT** определяет, когда должен запускаться обратный вызов дисплея, на основе состояния повторного отображения окна. Состояние повторного отображения окна может быть задано либо явно путем вызова **glutPostRedisplay**, либо неявно в результате повреждения окна, о котором сообщает оконная система. Несколько опубликованных повторных отображений для окна объединяются **GLUT**, чтобы свести к минимуму количество вызванных обратных вызовов дисплея.  

Когда наложение установлено для окна, но не зарегистрирован обратный вызов отображения наложения, обратный вызов дисплея используется для повторного отображения как наложения, так и нормальной плоскости (то есть он будет вызываться, если установлено либо состояние повторного отображения, либо состояние повторного отображения наложения). В этом случае используемый слой не изменяется неявно при входе в обратный вызов дисплея.  

См. **GluOverlayDisplayFunc**, чтобы понять, как могут быть установлены различные обратные вызовы для наложения и нормальной плоскости окна.  

Когда окно создается, для него не существует обратного вызова display. Программист несет ответственность за установку обратного вызова отображения для окна до того, как окно будет показано. Обратный вызов дисплея должен быть зарегистрирован для любого отображаемого окна. Если окно отображается без регистрации обратного вызова отображения, возникает фатальная ошибка. Передача *NULL* в **`glutDisplayFunc`** незаконна с **GLUT 3.0**; нет способа "отменить регистрацию" обратного вызова дисплея (хотя всегда можно зарегистрировать другую подпрограмму обратного вызова).  

По возвращении из обратного вызова дисплея нормальное поврежденное состояние окна (возвращаемое вызовом **glutLayerGet(*GLUT_NORMAL_DAMAGED*)** очищается. Если обратный вызов дисплея не зарегистрирован, поврежденное состояние окна окна (возвращаемое вызовом **glutLayerGet(*GLUT_OVERLAY_DAMAGED*)**) также очищено.  

[Источник](https://www.opengl.org/resources/libraries/glut/spec3/node46.html)
***

# glutMainLoop
**`glutMainLoop`** входит в цикл обработки событий GLUT.

## С спецификация
```c
void glutMainLoop(void);
```

## Описание
**`glutMainLoop`** входит в цикл обработки событий **GLUT**. Эта подпрограмма должна вызываться не более одного раза в программе **GLUT**. После вызова эта подпрограмма никогда не вернется. При необходимости он будет вызывать любые зарегистрированные обратные вызовы.

[Источник](https://www.opengl.org/resources/libraries/glut/spec3/node14.html)
***

# glutSwapBuffers
**`glutSwapBuffers`** меняет местами буферы текущего окна при двойной буферизации.

## С спецификация
```c
void glutSwapBuffers(void);
```

## Описание
Выполняет замену буфера на слое, используемом для текущего окна . В частности, **`glutSwapBuffers`** переводит содержимое заднего буфера слоя, используемого текущим окном , в содержимое переднего буфера. Содержимое заднего буфера становится неопределенным. Обновление обычно происходит во время вертикального возврата монитора, а не сразу после вызова **`glutSwapBuffers`**.  

Неявный **glFlush** выполняется **`glutSwapBuffers`** перед возвратом. Последующие команды OpenGL могут выполняться сразу после вызова **`glutSwapBuffers`** , но не выполняются до завершения обмена буферами.    

Если используемый слой не имеет двойной буферизации, **`glutSwapBuffers`** не действует.  

[Источник](https://www.opengl.org/resources/libraries/glut/spec3/node21.html)
***

# glClearColor
**`glClearColor`** — укажите четкие значения для цветовых буферов.

## С спецификация
```c
void glClearColor(GLclampf red,
                  GLclampf green,
                  GLclampf blue,
                  GLclampf alpha);

```

## Параметры
### *red, green, blue, alpha*
>Указывает значения красного, зеленого, синего и альфа-фактора, используемые при очистке цветовых буферов. Начальные значения равны 0.

## Описание
**`glClearColor`** задает значения красного, зеленого, синего и альфа-канала, используемые для очистки цветовых буферов. Значения, заданные параметром, зажаты в диапазоне **`glClearColor`** **[0,1]**.

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glClearColor.xml)
***

# glClear
**`glClear`** — очистка буферов для заданных значений

## С спецификация
```c
void glClear(	GLbitfield mask);
```

## Параметры
### *mask*
>Побитовое ИЛИ масок, указывающих на очищаемые буферы. Три маски: *GL_COLOR_BUFFER_BIT*, *GL_DEPTH_BUFFER_BIT*, и *GL_STENCIL_BUFFER_BIT*.
>
## Описание
**`glClear`** задает для области битовой плоскости окна значения, ранее выбранные параметрами **glClearColor**, **glClearDepth**, и **glClearStencil**. Несколько цветовых буферов можно очистить одновременно, выбрав более одного буфера одновременно с помощью **glDrawBuffer**.  

Тест владения пикселем, тест ножниц, дизеринг и буферные маски записи влияют на работу **`glClear`**. Ножничная коробка ограничивает очищенную область. Альфа-функция, функция смешивания, логическая операция, набор элементов, сопоставление текстур и буферизация глубины игнорируются **`glClear`**.  

**`glClear`** принимает один аргумент, который является побитовым ИЛИ нескольких значений, указывающих, какой буфер должен быть очищен.  

Принимает следующие значения:
|GL_COLOR_BUFFER_BIT   | Указывает буферы, включенные в данный момент для цветопередачи.|
|----------------------|----------------------------------------------------------------|
|GL_DEPTH_BUFFER_BIT   | Указывает буфер глубины.                                       |
|GL_STENCIL_BUFFER_BIT | Указывает буфер набора элементов.                              |

Значение, до которого очищается каждый буфер, зависит от значения очистки для этого буфера.

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml)
***

# glEnableVertexAttribArray, glDisableVertexAttribArray  (glDisableVertexArrayAttrib, glEnableVertexArrayAttrib)
**`glEnableVertexAttribArray`**, **`glDisableVertexAttribArray`** - включает и выключает универсальный массив атрибутов вершин соответственно.

## С спецификация
```c
void glEnableVertexAttribArray(GLuint index);

void glDisableVertexAttribArray(GLuint index);

void glEnableVertexArrayAttrib(GLuint vaobj,
                               GLuint index);
                               
void glDisableVertexArrayAttrib(GLuint vaobj,
                                GLuint index);
```

## Параметры
### *vaobj*
>Задает имя объекта массива вершин для **`glDisableVertexArrayAttrib`** и **`glEnableVertexArrayAttrib`** функций.
### *index*
>Задает индекс универсального атрибута вершин, который необходимо включить или отключить.

## Описание
**`glEnableVertexAttribArray`** и **`glEnableVertexArrayAttrib`** включает универсальный массив атрибутов вершины, заданный *index*. **`glEnableVertexAttribArray`** использует для операции привязанный в данный момент объект массива вершин, в то время как **`glEnableVertexArrayAttrib`** обновляет состояние объекта массива вершин идентификатором *vaobj*.  

**`glDisableVertexAttribArray`** и **`glDisableVertexArrayAttrib`** выключает универсальный массив атрибутов вершины, заданный *index*. **`glDisableVertexAttribArray`** использует для операции привязанный в данный момент объект массива вершин, в то время как **`glDisableVertexArrayAttrib`** обновляет состояние объекта массива вершин идентификатором *vaobj*.  

По умолчанию все возможности на стороне клиента отключены, включая все универсальные массивы атрибутов вершин. Если этот параметр включен, значения в универсальном массиве атрибутов вершин будут доступны и использованы для отрисовки при выполнении вызовов команд массива вершин, таких как **[glDrawArrays](#gldrawarrays)**, **glDrawElements**, **glDrawRangeElements**, **glMultiDrawElements**, or **glMultiDrawArrays**.  

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml)
***

# glBindBuffer
**`glBindBuffer`** — привязка именованного объекта буфера.

## С спецификация
```c
void glBindBuffer(GLenum target,
                  GLuint buffer);
```

## Параметры
### *target*
>Задает целевой объект, к которому привязан объект буфера, который должен быть одним из целевых объектов привязки буфера в следующей таблице:  
>
| Целевой объект привязки буфера | Цель                                         |
|--------------------------------|----------------------------------------------|
| GL_ARRAY_BUFFER	               |  Атрибуты вершин                             |
| GL_ATOMIC_COUNTER_BUFFER	     |  Хранение атомного счетчика                  |
| GL_COPY_READ_BUFFER	           |  Источник копирования буфера                 |
| GL_COPY_WRITE_BUFFER	         |  Назначение копирования буфера               |
| GL_DISPATCH_INDIRECT_BUFFER	   |  Команды диспетчеризации непрямых вычислений |
| GL_DRAW_INDIRECT_BUFFER	       |  Косвенные аргументы команды                 |
| GL_ELEMENT_ARRAY_BUFFER	       |  Индексы массива вершин                      |
| GL_PIXEL_PACK_BUFFER	         |  Целевой объект чтения пикселей              |
| GL_PIXEL_UNPACK_BUFFER	       |  Источник данных текстуры                    |
| GL_QUERY_BUFFER	               |  Буфер результатов запроса                   |
| GL_SHADER_STORAGE_BUFFER	     |  Хранилище для чтения и записи для шейдеров  |
| GL_TEXTURE_BUFFER              |  Буфер текстурных данных                     |
| GL_TRANSFORM_FEEDBACK_BUFFER	 |  Преобразование буфера обратной связи        |
| GL_UNIFORM_BUFFER              |  Равномерное блочное хранение                |
### *buffer*
>Задает имя объекта буфера.

## Описание
**`glBindBuffer`** привязывает объект буфера к указанной точке привязки буфера. Вызов **`glBindBuffer`** с *target*, установленным для одной из принятых символьных констант, и *buffer*, установленным с именем объекта буфера, привязывает это имя объекта буфера к целевому объекту. Если объект буфера с имен *buffer* не существует, создается объект с таким именем. Когда объект буфера привязан к целевому объекту, предыдущая привязка для этого целевого объекта автоматически разрывается.  

Имена объектов буфера являются целыми числами без знака. Нулевое значение зарезервировано, но для каждого целевого объекта буфера нет объекта буфера по умолчанию. Вместо этого *buffer*, равный нулю, эффективно отменяет привязку всех ранее привязанных объектов буфера и восстанавливает использование памяти клиента для этого целевого объекта буфера (если он поддерживается для этого целевого объекта). Имена объектов буфера и соответствующее содержимое объекта буфера являются локальными по отношению к общему пространству объектов текущего контекста рендеринга GL; два контекста рендеринга совместно используют имена объектов буфера только в том случае, если они явно разрешают совместное использование контекстов с помощью соответствующих функций интерфейсов **GL Windows**.

**[glGenBuffers](#glGenBuffers)** необходимо использовать для создания набора неиспользуемых имен объектов буфера.

Состояние объекта буфера сразу после его первой привязки представляет собой несопоставленный буфер памяти нулевого размера с *GL_READ_WRITE* доступом и *GL_STATIC_DRAW* использованием.  

В то время как имя ненулевого буферного объекта привязано, операции **GL** над целевым объектом, к которому он привязан, влияют на связанный объект буфера, а запросы целевого объекта, к которому он привязан, возвращают состояние из связанного объекта буфера. В то время как имя объекта буфера привязано к нулю, как и в начальном состоянии, попытка изменить или запросить состояние *GL_INVALID_OPERATION*, к которому он привязан, приводит к ошибке.  

Когда ненулевой объект буфера привязан к *GL_ARRAY_BUFFER*, параметр указателя массива вершин интерпретируется как смещение внутри объекта буфера, измеренное в базовых машинных единицах.  

Когда ненулевой объект буфера привязан к *GL_DRAW_INDIRECT_BUFFER*, параметры для чертежей, выдаваемых через **glDrawArraysIndirect** и **glDrawElementsIndirect**, поступают из указанного смещения в хранилище данных этого буферного объекта.  

Когда ненулевой объект буфера привязан к *GL_DISPATCH_INDIRECT_BUFFER*, параметры для вычислительных отправлений, выдаваемых через **glDispatchComputeIndirect**, поступают из указанного смещения в хранилище данных этого буферного объекта.  

В то время как ненулевой объект буфера привязан к *GL_ELEMENT_ARRAY_BUFFER*, параметр индексов **glDrawElements**, **glDrawElementsInstanced**, **glDrawElementsBaseVertex**, **glDrawRangeElements**, **glDrawRangeElementsBaseVertex**, **glMultiDrawElements**, или **glMultiDrawElementsBaseVertex** интерпретируется как смещение внутри буферного объекта, измеренное в базовых машинных единицах.  

Хотя ненулевой объект буфера привязан к *GL_PIXEL_PACK_BUFFER*, затрагиваются следующие команды: **glGetCompressedTexImage**, **glGetTexImage**, и **glReadPixels**. Параметр указателя интерпретируется как смещение внутри буферного объекта, измеренное в базовых машинных единицах.  

В то время как ненулевой объект буфера привязан к *GL_PIXEL_UNPACK_BUFFER*, затрагиваются следующие команды: **glCompressedTexImage1D**, **glCompressedTexImage2D**, **glCompressedTexImage3D**, **glCompressedTexSubImage1D**, **glCompressedTexSubImage2D**, **glCompressedTexSubImage3D**, **glTexImage1D**, **glTexImage2D**, **glTexImage3D**, **glTexSubImage1D**, **glTexSubImage2D**, и **glTexSubImage3D**. Параметр указателя интерпретируется как смещение внутри буферного объекта, измеренное в базовых машинных единицах.  

*GL_COPY_READ_BUFFER* и *GL_COPY_WRITE_BUFFER* предназначен для использования **glCopyBufferSubData** без нарушения состояния других привязок. Однако **glCopyBufferSubData** можно использовать с любой парой точек привязки буфера.  

*GL_TRANSFORM_FEEDBACK_BUFFER* привязки буфера может быть передана в **`glBindBuffer`**, но не будет напрямую влиять на состояние обратной связи преобразования. Вместо этого индексированные *GL_TRANSFORM_FEEDBACK_BUFFER* привязки должны использоваться путем вызова **glBindBufferBase** или **glBindBufferRange**. Это повлияет на общую привязку *GL_TRANSFORM_FEEDBACK_BUFFER*.  

Аналогичным образом, *GL_UNIFORM_BUFFER*, *GL_ATOMIC_COUNTER_BUFFER* и *GL_SHADER_STORAGE_BUFFER* привязки буфера могут использоваться, но не влияют напрямую на однородный буфер, буфер атомарного счетчика или состояние буфера хранилища шейдера соответственно. **glBindBufferBase** или **glBindBufferRange** необходимо использовать для привязки буфера к индексированному однородному буферу, буферу атомарного счетчика или точке привязки буфера хранилища шейдера.  

*GL_QUERY_BUFFER* привязки используется для указания объекта буфера, который должен получать результаты объектов запроса посредством вызовов семейства команд **glGetQueryObject**.  

Привязка буферного объекта, созданная с помощью **`glBindBuffer`**, остается активной до тех пор, пока другое имя объекта буфера не будет привязано к тому же целевому объекту или пока связанный объект буфера не будет удален с помощью **`glBindBuffer`**.

После создания именованный объект буфера может быть повторно привязан к любому целевому объекту так часто, как это необходимо. Однако реализация **GL** может сделать выбор в отношении того, как оптимизировать хранение буферного объекта на основе его начального целевого объекта привязки.

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml)
***

# glVertexAttribPointer (glVertexAttribIPointer, glVertexAttribLPointer)
**`glVertexAttribPointer`** (**`glVertexAttribIPointer`**, **`glVertexAttribLPointer`**) — определение массива универсальных атрибутов вершин.

## С спецификация
```c
void glVertexAttribPointer(GLuint index,
                           GLint size,
                           GLenum type,
                           GLboolean normalized,
                           GLsizei stride,
                           const void * pointer);
 
void glVertexAttribIPointer(GLuint index,
                            GLint size,
                            GLenum type,
                            GLsizei stride,
                            const void * pointer);
 
void glVertexAttribLPointer(GLuint index,
                            GLint size,
                            GLenum type,
                            GLsizei stride,
                            const void * pointer);
```

## Параметры
### *index*
>Задает индекс универсального атрибута вершины, который необходимо изменить.
### *size*
>Задает количество компонентов на универсальный атрибут вершины. Должно быть 1, 2, 3, 4. Кроме того, символическая константа принимается. Начальное значение равно 4.
### *type*
>Задает тип данных каждого компонента в массиве. Символьные константы *GL_BYTE* , *GL_UNSIGNED_BYTE* , *GL_SHORT* , *GL_UNSIGNED_SHORT* , *GL_INT* и *GL_UNSIGNED_INT* принимаются **`glVertexAttribPointer`** и **`glVertexAttribIPointer`** . Кроме того, *GL_HALF_FLOAT*, *GL_FLOAT*, *GL_DOUBLE*, *GL_FIXED*, *GL_INT_2_10_10_10_REV*, *GL_UNSIGNED_INT_2_10_10_10_REV* и *GL_UNSIGNED_INT_10F_11F_11F_REV* принимаются **`glVertexAttribPointer`**. *GL_DOUBLE* также принимается **`glVertexAttribLPointer`** и является единственным маркером, принимаемым параметром *type* для этой функции. Начальное значение — *GL_FLOAT* .
### *normalized*
>Указывает, должны ли значения данных с фиксированной точкой быть нормализованы (*GL_TRUE*) или преобразованы непосредственно в значения фиксированной точки (*GL_FALSE*) при доступе к ним.
### *stride*
>Задает смещение байта между последовательными универсальными атрибутами вершины. Если *stride* равен 0, то общие атрибуты вершины считаются плотно упакованными в массив. Начальное значение равно 0.
### *pointer*
>Задает смещение первого компонента первого универсального атрибута вершины в массиве в хранилище данных буфера, привязанного в данный момент к целевому объекту *GL_ARRAY_BUFFER*. Начальное значение равно 0.

## Описание
**`glVertexAttribPointer`**, **`glVertexAttribIPointer`** и **`glVertexAttribLPointer`** указывает расположение и формат данных массива универсальных атрибутов вершины в индекса *index*, которые будут использоваться при отрисовке. *size* указывает количество компонентов на атрибут и должен быть 1, 2, 3, 4 или *GL_BGRA*. *type* задает тип данных каждого компонента, *stride* а задает шаг байта от одного атрибута к другому, позволяя упаковывать вершины и атрибуты в один массив или хранить в отдельных массивах.  

Для **`glVertexAttribPointer`**, если для параметра *normalized* задано значение *GL_TRUE*, это означает, что значения, хранящиеся в целочисленном формате, должны сопоставляться с диапазоном [-1,1] (для знаковых значений) или [0,1] (для значений без знака) при доступе к ним и преобразовании в плавающую точку. В противном случае значения будут преобразованы в плавающие числа непосредственно без нормализации.  

Для **`glVertexAttribIPointer`**, принимаются только целочисленные типы *GL_BYTE*, *GL_UNSIGNED_BYTE*, *GL_SHORT*, *GL_UNSIGNED_SHORT*, *GL_INT, GL_UNSIGNED_INT*. Значения всегда оставляются как целочисленные значения.  

**`glVertexAttribLPointer`** задает состояние универсального массива атрибутов вершин, связанного с переменной атрибута шейдера, объявленной с 64-разрядными компонентами двойной точности. *type* должен быть *GL_DOUBLE*. *index*, *size*, и *stride* задаются так, как описано для **`glVertexAttribPointer`** и **`glVertexAttribIPointer`**.  

Если *pointer* не *NULL*, к целевому объекту должен быть привязан ненулевой *GL_ARRAY_BUFFER* (см. **[glBindBuffer](#glbindbuffer)**), в противном случае возникает ошибка. *pointer* обрабатывается как смещение байта в хранилище данных объекта буфера. Привязка объекта буфера (*GL_ARRAY_BUFFER_BINDING*) сохраняется как состояние массива универсальных атрибутов вершин (*GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*) для *index*.  

Если указан универсальный массив атрибутов вершин, *size*, *type*, *normalized*, *stride*, и *pointer* сохраняются как состояние массива вершин в дополнение к текущей привязке объекта буфера массива вершин.  

Чтобы включить и отключить универсальный массив атрибутов вершин, вызовите **[glEnableVertexAttribArray](#glenablevertexattribarray-gldisablevertexattribarray--gldisablevertexarrayattrib-glenablevertexarrayattrib)** и **[glDisableVertexAttribArray](#glenablevertexattribarray-gldisablevertexattribarray--gldisablevertexarrayattrib-glenablevertexarrayattrib)** с *index*. Если параметр массива атрибутовов вершин включен, то при использовании **[glDrawArrays](#gldrawarrays)**, **glMultiDrawArrays*, **glDrawElements**, **glMultiDrawElements**, или **glDrawRangeElements** вызывайте.  

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml)
***

# glDrawArrays
**`glDrawArrays`** — рендеринг примитивов из данных массива.
## С спецификация
```c
void glDrawArrays(GLenum mode,
                  GLint first,
                  GLsizei count);
```

## Параметры
### *mode*
>Указывает, какие примитивы необходимо отобразить. Символьные константы *GL_POINTS*, *GL_LINE_STRIP*, *GL_LINE_LOOP*, *GL_LINES*, *GL_LINE_STRIP_ADJACENCY*, *GL_LINES_ADJACENCY*, *GL_TRIANGLE_STRIP*, *GL_TRIANGLE_FAN*, *GL_TRIANGLES*, *GL_TRIANGLE_STRIP_ADJACENCY*, *GL_TRIANGLES_ADJACENCY* и *GL_PATCHES* принимаются.
### *first*
>Задает начальный индекс в включенных массивах.
### *count*
>Задает количество отображаемых индексов.

## Описание
**`glDrawArrays`** задает несколько геометрических примитивов с очень небольшим количеством вызовов подпрограмм. Вместо вызова процедуры **GL** для передачи каждой отдельной вершины, нормали, координаты текстуры, флага края или цвета можно предварительно указать отдельные массивы вершин, нормалей и цветов и использовать их для построения последовательности примитивов с одним вызовом **`glDrawArrays`**.  

При вызове **`glDrawArrays`** он использует ***count*** последовательных элементов из каждого включенного массива для построения последовательности геометрических примитивов, начиная с элемента *first*. *mode* определяет, какие примитивы создаются и как элементы массива конструируют эти примитивы.  

Атрибуты Vertex, которые изменяются **`glDrawArrays`**, имеют неопределенное значение после возвращения значений **`glDrawArrays`**. Атрибуты, которые не изменяются, остаются четко определенными.  

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml)
***

# glGenBuffers
**`glGenBuffers`** — генерация имен объектов буфера
## С спецификация
```c
void glGenBuffers(GLsizei n,
                  GLuint * buffers);
```

## Параметры
### *n*
>Задает количество имен создаваемых объектов буфера.
### *buffers*
>Задает массив, в котором хранятся созданные имена объектов буфера.

## Описание
**`glGenBuffers`** возвращает *n* имен объектов буфера в *buffers*. Нет никакой гарантии, что имена образуют непрерывное множество целых чисел; Однако гарантируется, что ни одно из возвращенных имен не использовалось непосредственно перед вызовом **`glGenBuffers`**.  
Имена объектов буфера, возвращаемые вызовом **`glGenBuffers`**, не возвращаются последующими вызовами, если они не будут сначала удалены с помощью **glDeleteBuffers**.  
Никакие объекты буфера не связываются с возвращенными именами объектов буфера, пока они не будут сначала связаны вызовом **[glBindBuffer](#glbindbuffer)**.  

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml)
***

# glBufferData
**`glBufferData`** — создает и инициализирует хранилище данных буферного объекта.
## С спецификация
```c
 void glBufferData(GLenum *target*,
                   GLsizeiptr *size*,
                   const void* *data*,
                   GLenum *usage*)
```
## Параметры
### *target*
>Задает целевой объект, к которому привязан объект буфера **`glBufferData`**, который должен быть одним из целевых объектов привязки буфера в следующей таблице:

| Целевой объект привязки буфера | Цель                                         |
|--------------------------------|----------------------------------------------|
| GL_ARRAY_BUFFER	               |  Атрибуты вершин                             |
| GL_ATOMIC_COUNTER_BUFFER	     |  Хранение атомного счетчика                  |
| GL_COPY_READ_BUFFER	           |  Источник копирования буфера                 |
| GL_COPY_WRITE_BUFFER	         |  Назначение копирования буфера               |
| GL_DISPATCH_INDIRECT_BUFFER	   |  Команды диспетчеризации непрямых вычислений |
| GL_DRAW_INDIRECT_BUFFER	       |  Косвенные аргументы команды                 |
| GL_ELEMENT_ARRAY_BUFFER	       |  Индексы массива вершин                      |
| GL_PIXEL_PACK_BUFFER	         |  Целевой объект чтения пикселей              |
| GL_PIXEL_UNPACK_BUFFER	       |  Источник данных текстуры                    |
| GL_QUERY_BUFFER	               |  Буфер результатов запроса                   |
| GL_SHADER_STORAGE_BUFFER	     |  Хранилище для чтения и записи для шейдеров  |
| GL_TEXTURE_BUFFER              |  Буфер текстурных данных                     |
| GL_TRANSFORM_FEEDBACK_BUFFER	 |  Преобразование буфера обратной связи        |
| GL_UNIFORM_BUFFER              |  Равномерное блочное хранение                |

>Атрибуты вершин.
### *size*
>Задает размер нового хранилища данных объекта буфера в байтах.
### *data*
>Задает указатель на данные, которые будут скопированы в хранилище данных для инициализации или *NULL* если данные не должны быть скопированы.
### *usage*
>Задает ожидаемый шаблон использования хранилища данных. Символическая константа должна быть *GL_STREAM_DRAW*, *GL_STREAM_READ*, *GL_STREAM_COPY*, *GL_STATIC_DRAW*, *GL_STATIC_READ*, *GL_STATIC_COPY*, *GL_DYNAMIC_DRAW*, *GL_DYNAMIC_READ*, или *GL_DYNAMIC_COPY*.  

## Описание
**`glBufferData`** создает новое хранилище данных для объекта буфера, который в настоящее время привязан к *target*. Любое ранее существовавшее хранилище данных удаляется. Новое хранилище данных создается с указанными *size* в байтах и *usage*. Если *data* не *NULL*, хранилище данных инициализируется данными из этого указателя. В исходном состоянии новое хранилище данных не сопоставлено, оно имеет *NULL* сопоставленный указатель и сопоставленный доступ к нему *GL_READ_WRITE*.  

*usage* является подсказкой для реализации **GL** о том, как будет осуществляться доступ к хранилищу данных буферного объекта. Это позволяет реализации **GL** принимать более разумные решения, которые могут значительно повлиять на производительность объекта буфера. Однако это не ограничивает фактическое использование хранилища данных. *usage* можно разбить на две части: во-первых, частота доступа (модификация и использование) и, во-вторых, характер этого доступа.  

Частота доступа может быть одной из следующих:  

**STREAM**
>Содержимое хранилища данных будет изменено один раз и использовано не более нескольких раз.  

**STATIC**
>Содержимое хранилища данных будет изменено один раз и использовано много раз.  
>
**DYNAMIC**
>Содержимое хранилища данных будет неоднократно изменяться и использоваться много раз.  

Характер доступа может быть одним из следующих:  

**DRAW**
>Cодержимое хранилища данных изменяется приложением и используется в качестве источника для команд рисования **GL** и спецификации изображения.  
>
**READ**
>Содержимое хранилища данных изменяется путем чтения данных из **GL** и используется для возврата этих данных при запросе приложением.  
>
**COPY**
>Содержимое хранилища данных изменяется путем считывания данных из **GL** и используется в качестве источника для команд рисования **GL** и спецификации изображения. 

[Источник](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml)
***
